/Users/avio./dev/sb-ai-vision-demo/pygame-demos/falling_shapes.py:
import pygame
from shared import game_settings as settings
from scenes.start_game import StartGame
from scenes.game import Game
from scenes.game_over import GameOver, GameOverConfig
from scenes.spaceship_selection import SpaceshipSelection
from shared.game_state import game_state

class FallingShapes:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((settings.SCREEN_WIDTH, settings.SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()

        # Initialize GameOverConfig
        game_over_config = GameOverConfig()

        # Provide the required arguments for GameOver
        audio_file = "assets/game_over/story.mp3"
        image_files = ["assets/game_over/story1.png", "assets/game_over/story2.png", "assets/game_over/story3.png"]

        self.scenes = {
            "start_game": StartGame(self.screen),
            "spaceship_selection": SpaceshipSelection(self.screen),
            "game": Game(self.screen),
            "game_over": GameOver(self.screen, audio_file, image_files, game_over_config)


        }

        self.current_scene = "start_game"

    def run(self):
        running = True
        while running:
            dt = self.clock.tick(60) / 1000

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                self.scenes[self.current_scene].handle_events(event)

            self.scenes[self.current_scene].update(dt)
            if self.scenes[self.current_scene].next_scene:
                if self.current_scene == "spaceship_selection" and self.scenes[self.current_scene].next_scene == "game":
                    self.scenes["game"] = Game(self.screen)  # Create the game scene
                elif self.current_scene == "game_over" and self.scenes[self.current_scene].next_scene == "start_game":
                    game_state.set_selected_spaceship(None)  # Reset the selected spaceship
                self.current_scene = self.scenes[self.current_scene].next_scene
                self.scenes[self.current_scene].reset()
                
                # Reset the next_scene attribute of the previous scene
                for scene_name, scene in self.scenes.items():
                    if scene_name != self.current_scene:
                        scene.next_scene = None

            self.scenes[self.current_scene].draw()

            pygame.display.flip()

        pygame.quit()



if __name__ == "__main__":
    game = FallingShapes()
    game.run()

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/rig_demo.py:
import pygame
import json
import math
import random

# Initialize Pygame
pygame.init()

# Set the window size
window_size = (800, 600)
screen = pygame.display.set_mode(window_size)
pygame.display.set_caption("Butterfly Animation")

# Define colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Load the animation data from JSON
animation_data = [
    {"object": "circle", "position": [50, 550], "size": 10, "time": 0, "pen_down": True, "weight": 1},
    {"object": "circle", "position": [100, 500], "size": 12, "time": 10, "pen_down": True, "weight": 1},
    {"object": "circle", "position": [150, 450], "size": 14, "time": 20, "pen_down": True, "weight": 1},
    {"object": "circle", "position": [200, 400], "size": 16, "time": 30, "pen_down": True, "weight": 1},
    {"object": "circle", "position": [250, 350], "size": 18, "time": 40, "pen_down": False, "weight": 2},
    {"object": "circle", "position": [300, 300], "size": 20, "time": 50, "pen_down": False, "weight": 2},
    {"object": "circle", "position": [350, 250], "size": 22, "time": 60, "pen_down": True, "weight": 3},
    {"object": "circle", "position": [400, 200], "size": 24, "time": 70, "pen_down": True, "weight": 3},
    {"object": "circle", "position": [450, 150], "size": 26, "time": 80, "pen_down": True, "weight": 4},
    {"object": "circle", "position": [500, 100], "size": 28, "time": 90, "pen_down": True, "weight": 4},
    {"object": "circle", "position": [550, 50], "size": 30, "time": 100, "pen_down": True, "weight": 5},
    {"object": "circle", "position": [600, 0], "size": 32, "time": 110, "pen_down": True, "weight": 5},
]

def draw_shape(shape, position, size):
    if shape == "circle":
        pygame.draw.circle(screen, BLACK, position, size, 1)
    elif shape == "rectangle":
        pygame.draw.rect(screen, BLACK, (position[0], position[1], size, size), 1)
    elif shape == "square":
        pygame.draw.rect(screen, BLACK, (position[0], position[1], size, size), 1)

def animate_shape(start_pos, end_pos, start_size, end_size, start_time, end_time, current_time, pen_down, weight):
    if current_time >= end_time:
        return end_pos, end_size
    else:
        progress = (current_time - start_time) / (end_time - start_time)
        x = start_pos[0] + progress * (end_pos[0] - start_pos[0])
        y = start_pos[1] + progress * (end_pos[1] - start_pos[1])
        size = start_size + progress * (end_size - start_size)
        
        # Add random perturbations to the position
        x += random.randint(-5, 5)
        y += random.randint(-5, 5)
        
        # Add vertical oscillation
        y += 20 * math.sin(progress * 2 * math.pi)
        
        # Apply gravity based on weight
        y += weight * progress
        
        if pen_down:
            pygame.draw.line(screen, BLACK, start_pos, (x, y), 1)
        
        return [int(x), int(y)], int(size)

# Game loop
running = True
clock = pygame.time.Clock()
frame_count = 0

while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    screen.fill(WHITE)

    current_shape_index = None
    for i in range(len(animation_data)):
        if frame_count >= animation_data[i]["time"]:
            current_shape_index = i
        else:
            break

    if current_shape_index is not None:
        current_shape = animation_data[current_shape_index]
        if current_shape_index < len(animation_data) - 1:
            next_shape = animation_data[current_shape_index + 1]
            position, size = animate_shape(current_shape["position"], next_shape["position"], current_shape["size"], next_shape["size"], current_shape["time"], next_shape["time"], frame_count, current_shape["pen_down"], current_shape["weight"])
        else:
            position, size = current_shape["position"], current_shape["size"]
        draw_shape(current_shape["object"], position, size)

    pygame.display.flip()
    clock.tick(60)
    frame_count += 1

# Quit the game
pygame.quit()

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/game_runner.py:
import os
import subprocess
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class GameReloader(FileSystemEventHandler):
    def __init__(self):
        self.process = None

    def on_modified(self, event):
        if event.src_path.endswith('.py'):
            print(f"Changes detected in {event.src_path}. Reloading the game...")
            self.reload_game()

    def reload_game(self):
        if self.process:
            self.process.terminate()
        self.process = subprocess.Popen(['python', 'falling_shapes.py'])

if __name__ == "__main__":
    path = '.'
    event_handler = GameReloader()
    observer = Observer()
    observer.schedule(event_handler, path, recursive=True)
    observer.start()

    # Run the game initially
    event_handler.reload_game()

    try:
        while True:
            pass
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/scenes/start_game.py:
import pygame
from shared import game_settings as settings
from shared.scene import Scene
from shared.font import load_font
from shared.ui import draw_rectangle
from shared.ui import draw_breathing_text
class StartGame(Scene):
    def __init__(self, screen):
        super().__init__(screen)
        self.screen = screen
        self.background_image = pygame.image.load('assets/start_game/game-intro.png')
        self.background = pygame.transform.scale(self.background_image, (settings.SCREEN_WIDTH, settings.SCREEN_HEIGHT))
        self.breathing_duration = 1200
        self.breathing_timer = 0


    def reset(self):
        pass

    def handle_events(self, event):
        if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
            self.next_scene = "spaceship_selection"  # Set the next_scene attribute to "spaceship_selection"
        return None

    def update(self, dt):
        self.breathing_timer = (self.breathing_timer + dt * 1000) % self.breathing_duration


    def draw(self):
        self.screen.fill(settings.BLACK)
        self.screen.blit(self.background, (0, 0))

        text_bg_color = (50, 50, 50)  # Dark gray
        draw_rectangle(self.screen, 0, settings.SCREEN_HEIGHT - 85, settings.SCREEN_WIDTH, 50, text_bg_color, opacity=153)

        draw_breathing_text(self.screen, "Press Enter to Start", settings.WHITE, (settings.SCREEN_WIDTH // 2, settings.SCREEN_HEIGHT - 60), self.breathing_duration, self.breathing_timer)


/Users/avio./dev/sb-ai-vision-demo/pygame-demos/scenes/spaceship_selection.py:
import pygame
from shared import game_settings as settings
from shared.scene import Scene
from shared.font import load_font
from shared.game_state import game_state
from shared.ui import draw_info_box

class SpaceshipSelection(Scene):

    def __init__(self, screen):
        super().__init__(screen)  # Call the parent class constructor
        self.screen = screen
        self.spaceships = [
            {"image": "assets/spaceships/spaceship1.png", "name": "Sparrow", "damage": 10, "speed": 50, "reload_rate": 1},
            {"image": "assets/spaceships/spaceship2.png", "name": "Phoenix", "damage": 15, "speed": 80, "reload_rate": 0.8},
            {"image": "assets/spaceships/spaceship3.png", "name": "Falcon", "damage": 12, "speed": 150, "reload_rate": 1.2},
            {"image": "assets/spaceships/spaceship4.png", "name": "Eagle", "damage": 4, "speed": 250, "reload_rate": 0.3}
        ]
        self.selected_spaceship = 0
        self.load_images()


    def load_images(self):
        self.spaceship_images = [pygame.image.load(spaceship["image"]) for spaceship in self.spaceships]
        self.scaled_images = []
        for image in self.spaceship_images:
            aspect_ratio = image.get_height() / image.get_width()
            new_width = int(settings.SCREEN_WIDTH * 0.7)
            new_height = int(new_width * aspect_ratio)
            scaled_image = pygame.transform.scale(image, (new_width, new_height))
            self.scaled_images.append(scaled_image)

    def reset(self):
        self.selected_spaceship = 0  # Reset the selected spaceship to the first one
        self.next_scene = None  # Reset the next_scene attribute

    def handle_events(self, event):
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT:
                self.selected_spaceship = (self.selected_spaceship - 1) % len(self.spaceships)
            elif event.key == pygame.K_RIGHT:
                self.selected_spaceship = (self.selected_spaceship + 1) % len(self.spaceships)
            elif event.key == pygame.K_RETURN:
                selected_spaceship = self.spaceships[self.selected_spaceship]
                game_state.set_selected_spaceship(selected_spaceship)
                self.switch_to_scene("game")



    def update(self, dt):
        pass

    def draw(self):
        self.screen.fill(settings.BLACK)
        
        title_font = load_font(24)
        title_text = title_font.render("Select Your Ship", True, settings.WHITE)
        title_rect = title_text.get_rect(centerx=settings.SCREEN_WIDTH // 2, y=30)
        self.screen.blit(title_text, title_rect)
        
        current_image = self.scaled_images[self.selected_spaceship]
        x = settings.SCREEN_WIDTH // 2 - current_image.get_width() // 2
        y = 80
        self.screen.blit(current_image, (x, y))

        info_x = settings.SCREEN_WIDTH // 2 - 150
        info_y = settings.SCREEN_HEIGHT // 2

        name_font = load_font(18)
        current_spaceship = self.spaceships[self.selected_spaceship]
        name_text = name_font.render(current_spaceship['name'], True, settings.WHITE)
        name_rect = name_text.get_rect(topleft=(info_x, info_y))
        self.screen.blit(name_text, name_rect)

        info_titles = ["Damage", "Speed", "Reload Rate"]
        info_values = [current_spaceship['damage'], current_spaceship['speed'], current_spaceship['reload_rate']]

        for i, (title, value) in enumerate(zip(info_titles, info_values)):
            draw_info_box(self.screen, title, value, info_x, info_y + 40 + i * 30)

        padding = 10  # Adjust this value to change the spacing/padding

        for i, spaceship in enumerate(self.spaceship_images):
            small_spaceship = pygame.transform.scale(spaceship, (64, 64))
            x = (i % 4) * (64 + 20) + (settings.SCREEN_WIDTH - (64 * 4 + 20 * 3)) // 2
            y = settings.SCREEN_HEIGHT - 100 - padding
            self.screen.blit(small_spaceship, (x, y))

            if i == self.selected_spaceship:
                pygame.draw.line(self.screen, settings.WHITE, (x, y + 64 + padding), (x + 64, y + 64 + padding), 1)

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/scenes/game.py:
import pygame
from shared import game_settings as settings
from shared.grid import draw_grid
from shared.player import Player
from shared.npc import NPC
from shared.scene import Scene
from shared.font import load_font
from shared.ui import draw_info_box
from shared.game_state import game_state

class Game(Scene):
    def __init__(self, screen):
        super().__init__(screen)
        self.screen = screen
        selected_spaceship = game_state.get_selected_spaceship()
        if selected_spaceship is None:
            # Set a default spaceship if none is selected
            selected_spaceship = {
                "image": "assets/spaceships/spaceship1.png",
                "damage": 10,
                "speed": 5,
                "reload_rate": 1
            }

        self.player = Player(self.screen, selected_spaceship, offset_y=20)
        self.score = 0
        self.game_over = False
        self.npc_spawn_interval = 1250
        self.npc_last_spawn_time = 0
        self.max_npcs = 6
        self.npcs = []
        self.background_image = pygame.image.load('assets/game-bg.png')
        self.background = pygame.transform.scale(self.background_image, (settings.SCREEN_WIDTH, settings.SCREEN_HEIGHT))



        self.player = Player(self.screen, selected_spaceship, offset_y=20)
        self.score = 0
        self.game_over = False
        self.npc_spawn_interval = 1250
        self.npc_last_spawn_time = 0
        self.max_npcs = 6
        self.npcs = []
        self.background_image = pygame.image.load('assets/game-bg.png')
        self.background = pygame.transform.scale(self.background_image, (settings.SCREEN_WIDTH, settings.SCREEN_HEIGHT))
        

    def reset(self):
        selected_spaceship = game_state.get_selected_spaceship()
        if selected_spaceship is None:
            # Set a default spaceship if none is selected
            selected_spaceship = {
                "image": "assets/spaceships/spaceship1.png",
                "damage": 10,
                "speed": 5,
                "reload_rate": 1
            }
        self.player.reset(selected_spaceship)
        self.player.health = 100  # Reset the player's health
        self.score = 0
        self.game_over = False
        self.npc_last_spawn_time = 0
        self.npcs = []
        self.next_scene = None  # Reset the next_scene attribute

    def handle_events(self, event):
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT:
                self.player.moving_left = True
            elif event.key == pygame.K_RIGHT:
                self.player.moving_right = True
            elif event.key == pygame.K_g:
                settings.SHOW_GRID = not settings.SHOW_GRID
        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_LEFT:
                self.player.moving_left = False
            elif event.key == pygame.K_RIGHT:
                self.player.moving_right = False

    def update(self, dt):
        self.player.update(dt)
        self.player.shoot()  # Call the shoot method in the update loop
        self.update_npcs(dt)
        self.spawn_npcs()
        self.check_collisions()

        if not self.player.is_alive():
            self.game_over = True
            self.switch_to_scene("game_over")




    def update_npcs(self, dt):
        for npc in self.npcs:
            npc.update(dt)
            if npc.is_off_screen() or npc.to_remove:
                self.npcs.remove(npc)

    def spawn_npcs(self):
        current_time = pygame.time.get_ticks()
        if current_time - self.npc_last_spawn_time >= self.npc_spawn_interval and len(self.npcs) < self.max_npcs:
            npc = NPC(self.screen)
            self.npcs.append(npc)
            self.npc_last_spawn_time = current_time

    def check_collisions(self):
        for bullet in self.player.bullets:
            for npc in self.npcs:
                if npc.collides_with(bullet):
                    self.score += 10
                    npc.on_collision(bullet)
                    break
        
        for npc in self.npcs:
            if self.player.collides_with(npc):
                self.player.on_collision(npc)
                npc.remove()
            
            if npc.y + npc.size > settings.SCREEN_HEIGHT:  # Check if NPC hits the ground
                self.player.on_miss()
                npc.reset()


    def draw(self):
        self.screen.blit(self.background, (0, 0))

        if settings.SHOW_GRID:
            draw_grid(self.screen)

        self.player.draw()

        for npc in self.npcs:
            npc.draw()

        self.draw_score_and_health()


    def draw_score_and_health(self):
        draw_info_box(self.screen, "Score", self.score, 15, 20, 95)
        draw_info_box(self.screen, "Health", self.player.health, 15, 50, 95)


/Users/avio./dev/sb-ai-vision-demo/pygame-demos/scenes/game_over.py:
import pygame
from shared import game_settings as settings
import math
from shared.scene import Scene
from shared.font import load_font
from shared.ui import draw_rectangle
from shared.ui import draw_breathing_text

class GameOverConfig:
    def __init__(self):
        self.fade_out_duration = 1000  # Fade out duration in milliseconds
        self.breathing_duration = 1200  # Breathing effect duration in milliseconds
        self.zoom_speed = 0.05
        self.pan_speed = 0.02
        self.max_zoom_level = 1.8

class GameOver(Scene):
    def __init__(self, screen, audio_file, image_files, config):
        super().__init__(screen)  # Call the parent class constructor
        self.screen = screen
        self.audio_file = audio_file
        self.image_files = image_files
        self.config = config
        self.audio_duration = 0
        self.image_duration = 0
        self.current_image_index = 0
        self.start_time = 0
        self.sequence_played = False
        self.fade_out_alpha = 255
        self.breathing_timer = 0
        self.text_alpha = 255
        self.zoom_level = 1.0
        self.pan_x = 0
        self.pan_y = 0
        self.target_pan_x = 0
        self.target_pan_y = 0
        self.breathing_duration = config.breathing_duration


        self.load_assets()





    def load_assets(self):
        pygame.mixer.music.load(self.audio_file)
        self.audio_duration = pygame.mixer.Sound(self.audio_file).get_length() * 1000  # Convert to milliseconds
        
        self.images = [self.scale_image(image_file) for image_file in self.image_files]
        self.image_duration = self.audio_duration // len(self.images)

    def scale_image(self, image_file):
        image = pygame.image.load(image_file)
        aspect_ratio = image.get_width() / image.get_height()
        
        if aspect_ratio > settings.SCREEN_WIDTH / settings.SCREEN_HEIGHT:
            new_width = settings.SCREEN_WIDTH
            new_height = int(new_width / aspect_ratio)
        else:
            new_height = settings.SCREEN_HEIGHT
            new_width = int(new_height * aspect_ratio)
        
        return pygame.transform.scale(image, (new_width, new_height))

    def handle_events(self, event):
        if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
            pygame.mixer.music.stop()
            self.next_scene = "start_game"  # Set the next_scene attribute to "start_game"



    def smooth_value(self, start, end, t):
        t = min(max(t, 0.0), 1.0)  # Clamp t between 0 and 1
        t = (1 - math.cos(t * math.pi)) / 2  # Smooth the value using a cosine function
        return start * (1 - t) + end * t

    def update(self, dt):
        if not pygame.mixer.music.get_busy() and not self.sequence_played:
            self.start_time = pygame.time.get_ticks()
            pygame.mixer.music.play()
            self.sequence_played = True
            self.reset_zoom_pan()

        if self.sequence_played:
            elapsed_time = pygame.time.get_ticks() - self.start_time
            prev_image_index = self.current_image_index
            self.current_image_index = int(min(elapsed_time // self.image_duration, len(self.images) - 1))

            if self.current_image_index != prev_image_index:
                self.reset_zoom_pan()
                self.set_target_pan()

            if elapsed_time >= self.audio_duration:
                pygame.mixer.music.stop()
                self.fade_out_alpha = max(self.fade_out_alpha - int(255 * dt / (self.config.fade_out_duration / 1000)), 0)

            self.update_zoom_pan(dt)

        self.breathing_timer = (self.breathing_timer + dt * 1000) % self.breathing_duration
        self.text_alpha = int(255 * (1 - (self.breathing_timer / self.config.breathing_duration)))

    def reset_zoom_pan(self):
        self.zoom_level = 1.0
        self.pan_x = 0
        self.pan_y = 0
        self.target_pan_x = 0
        self.target_pan_y = 0

    def set_target_pan(self):
        self.target_pan_x = (self.current_image_index % 2) * 100 - 50  # Alternate between -50 and 50
        self.target_pan_y = (self.current_image_index % 2) * 60 - 30  # Alternate between -30 and 30

    def update_zoom_pan(self, dt):
        self.zoom_level = min(self.zoom_level + self.config.zoom_speed * dt, self.config.max_zoom_level)
        self.pan_x = self.smooth_value(self.pan_x, self.target_pan_x, self.config.pan_speed)
        self.pan_y = self.smooth_value(self.pan_y, self.target_pan_y, self.config.pan_speed)

    def draw(self):
        if self.current_image_index >= 0:
            image = self.images[self.current_image_index]
            image_rect = image.get_rect()
            image_rect.center = (settings.SCREEN_WIDTH // 2, settings.SCREEN_HEIGHT // 2)

            scaled_width = int(image_rect.width * self.zoom_level)
            scaled_height = int(image_rect.height * self.zoom_level)
            scaled_image = pygame.transform.scale(image, (scaled_width, scaled_height))
            scaled_rect = scaled_image.get_rect()
            scaled_rect.center = (settings.SCREEN_WIDTH // 2 + self.pan_x, settings.SCREEN_HEIGHT // 2 + self.pan_y)

            image_copy = scaled_image.copy()
            image_copy.set_alpha(self.fade_out_alpha)
            self.screen.blit(image_copy, scaled_rect)
        else:
            self.screen.fill(settings.BLACK)

        
        text_bg_color = (50, 50, 50)  # Dark gray
        draw_rectangle(self.screen, 0, settings.SCREEN_HEIGHT - 75, settings.SCREEN_WIDTH, 50, text_bg_color, opacity=160)
        draw_breathing_text(self.screen, "Press Enter to Try Again", settings.WHITE, (settings.SCREEN_WIDTH // 2, settings.SCREEN_HEIGHT - 50), self.breathing_duration, self.breathing_timer)
        

    def draw_text(self, text, color, center, alpha=255):
        font = load_font(18)
        text_surface = font.render(text, True, color)
        text_rect = text_surface.get_rect(center=center)
        text_surface.set_alpha(alpha)
        self.screen.blit(text_surface, text_rect)

    def reset(self):
        pygame.mixer.music.stop()
        self.current_image_index = 0
        self.start_time = 0
        self.sequence_played = False
        self.fade_out_alpha = 255
        self.breathing_timer = 0
        self.text_alpha = 255
        self.reset_zoom_pan()
        self.next_scene = None  # Reset the next_scene attribute


/Users/avio./dev/sb-ai-vision-demo/pygame-demos/shared/game_state.py:
# game_state.py
class GameState:
    def __init__(self):
        self.selected_spaceship = None

    def set_selected_spaceship(self, spaceship):
        self.selected_spaceship = spaceship

    def get_selected_spaceship(self):
        return self.selected_spaceship

game_state = GameState()

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/shared/grid.py:
import pygame
from shared import game_settings as settings
from shared.font import load_font

def draw_text(screen, text, x, y, color=settings.GREY, font_size=34):
    font = load_font(font_size)
    text_surface = font.render(text, True, color)
    text_rect = text_surface.get_rect(center=(x, y))
    screen.blit(text_surface, text_rect)

def draw_grid(screen):
    column_width = settings.SCREEN_WIDTH / settings.GRID_COLUMNS
    row_height = settings.SCREEN_HEIGHT / settings.GRID_ROWS

    # Draw vertical lines for the grid
    for col in range(settings.GRID_COLUMNS + 1):
        pygame.draw.line(screen, settings.GREY, (col * column_width, 0), (col * column_width, settings.SCREEN_HEIGHT))

    # Draw horizontal lines for the grid
    for row in range(settings.GRID_ROWS + 1):
        pygame.draw.line(screen, settings.GREY, (0, row * row_height), (settings.SCREEN_WIDTH, row * row_height))

    # Draw text in each cell
    for col in range(settings.GRID_COLUMNS):
        for row in range(settings.GRID_ROWS):
            cell_text = f"{row},{col}"
            text_x = col * column_width + column_width / 2
            text_y = row * row_height + row_height / 2
            draw_text(screen, cell_text, text_x, text_y, settings.GREY)

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/shared/npc.py:
# npc.py
import pygame
import random
from shared import game_settings as settings
from shared.bullet import Bullet
from shared.game_object import GameObject
from shared.game_state import game_state

class NPC(GameObject):
    def __init__(self, screen):

        self.move_direction = 1  # 1 for right, -1 for left
        self.move_interval = random.randint(30, 90)  # Random interval for changing direction
        self.move_timer = 0
        self.speed = 25.0  # Adjust this value to control the speed


        self.screen = screen
        self.size = 48
        self.speed = 155.1
        self.color = (255, 127, 120)  # Coral
        self.hit_tint_duration = 4
        self.hit_tint_color = (255, 0, 0)  # Red
        self.hit_tint_timer = 0
        
        

        self.original_image = pygame.image.load('assets/enemy.png')
        self.image = pygame.transform.scale(self.original_image, (self.size, self.size))
        super().__init__(0, 0, self.size, self.speed)
        self.reset()

        selected_spaceship = game_state.get_selected_spaceship()
        self.health = 10 * selected_spaceship['damage']
        

        

    def reset(self):
        self.x = random.randint(0, settings.SCREEN_WIDTH - self.size)
        self.y = 0
        self.hit_tint_timer = 0
        self.move_direction = random.choice([-1, 1])  # Randomly choose the initial direction
        self.move_timer = 0
        self.move_interval = random.randint(30, 90)  # Set a new random interval


    def move(self, dt):
        self.y += self.speed * dt
        self.x += self.move_direction * self.speed * dt

        self.move_timer += 1
        if self.move_timer >= self.move_interval:
            self.move_direction *= -1  # Change direction
            self.move_timer = 0
            self.move_interval = random.randint(30, 90)  # Set a new random interval

        # Keep the NPC within the screen bounds
        if self.x <= 0:
            self.x = 0
            self.move_direction = 1
        elif self.x >= settings.SCREEN_WIDTH - self.size:
            self.x = settings.SCREEN_WIDTH - self.size
            self.move_direction = -1

        if self.is_off_screen():
            self.remove()


    def update(self, dt):
        self.move(dt)
        if self.hit_tint_timer > 0:
            self.hit_tint_timer -= 1
            if self.hit_tint_timer <= 0:
                self.remove()  # Check for removal after hit tint timer expires

    def draw(self):
        if self.hit_tint_timer > 0:
            tinted_image = self.image.copy()
            tinted_image.fill(self.hit_tint_color, special_flags=pygame.BLEND_RGB_MULT)
            self.screen.blit(tinted_image, (int(self.x), int(self.y)))
        else:
            self.screen.blit(self.image, (int(self.x), int(self.y)))

    def on_collision(self, target):
        if isinstance(target, Bullet):
            self.start_hit_tint()
            target.remove()
            # Check if the hit tint timer has expired before removing the NPC
            if self.hit_tint_timer <= 0:
                self.remove()

    def start_hit_tint(self):
        self.hit_tint_timer = self.hit_tint_duration

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/shared/ui.py:
import pygame
from shared import game_settings as settings
from shared.font import load_font

def draw_info_box(screen, title, value, x, y, title_width=135):

    title_font = load_font(12)
    value_font = load_font(14)

    title_text = title_font.render(title, True, settings.LIGHT_GREY)
    value_text = value_font.render(str(value), True, settings.WHITE)

    title_rect = title_text.get_rect(topleft=(x, y))
    value_rect = value_text.get_rect(topleft=(x + title_width, y))

    screen.blit(title_text, title_rect)
    screen.blit(value_text, value_rect)

def draw_rectangle(screen, x, y, width, height, color, opacity=255):
    rect_surface = pygame.Surface((width, height), pygame.SRCALPHA)
    rect_surface.fill(color + (opacity,))
    screen.blit(rect_surface, (x, y))


def draw_breathing_text(screen, text, color, center, breathing_duration, timer):
    font = load_font(18)
    text_surface = font.render(text, True, color)
    text_rect = text_surface.get_rect(center=center)
    text_alpha = int(255 * (1 - (timer / breathing_duration)))
    text_surface.set_alpha(text_alpha)
    screen.blit(text_surface, text_rect)

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/shared/scene.py:
# scene.py
import pygame

class Scene:
    def __init__(self, screen):
        self.screen = screen
        self.next_scene = None

    def handle_events(self, event):
        pass

    def update(self, dt):
        pass

    def draw(self):
        pass

    def reset(self):
        pass

    def switch_to_scene(self, next_scene):
        self.next_scene = next_scene

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/shared/font.py:
import pygame

def load_font(font_size):
    return pygame.font.Font("assets/fonts/joystix monospace.otf", font_size)

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/shared/player.py:
import pygame
from shared import game_settings as settings
import math
from shared.npc import NPC
from shared.bullet import Bullet
from shared.game_state import game_state

PADDLE_WIDTH = 100
PADDLE_HEIGHT = 90


class Player:
    def __init__(self, screen, selected_spaceship, offset_x=0, offset_y=0):
        self.screen = screen
        self.original_image = pygame.image.load(selected_spaceship['image'])
        self.width = PADDLE_WIDTH
        self.height = PADDLE_HEIGHT
        self.image = pygame.transform.scale(self.original_image, (self.width, self.height))
        self.x = settings.SCREEN_WIDTH // 2 - self.width // 2
        self.y = settings.SCREEN_HEIGHT - self.height - offset_y
        self.bullets = []
        self.health = 100
        self.moving_left = False
        self.moving_right = False
        # Hit tint attributes
        self.hit_tint_duration = 3
        self.last_shot_time = 0
        self.hit_tint_timer = 0
        self.hit_tint_color = (255, 0, 0)  # Red for hit tint

        self.speed = selected_spaceship['speed']      
        self.reload_rate = selected_spaceship['reload_rate']


    def reset(self, selected_spaceship):
        self.original_image = pygame.image.load(selected_spaceship['image'])
        self.width = PADDLE_WIDTH
        self.height = PADDLE_HEIGHT
        self.image = pygame.transform.scale(self.original_image, (self.width, self.height))
        self.x = settings.SCREEN_WIDTH // 2 - self.width // 2
        self.y = settings.SCREEN_HEIGHT - self.height - 20  # Adjust the offset as needed
        self.bullets = []
        self.moving_left = False
        self.moving_right = False
        self.hit_tint_timer = 0
        self.speed = selected_spaceship['speed']        
        self.reload_rate = selected_spaceship['reload_rate']

    def shoot(self):
        current_time = pygame.time.get_ticks()
        if pygame.key.get_pressed()[pygame.K_SPACE] and current_time - self.last_shot_time >= self.reload_rate * 1000:
            bullet_x = self.x + self.width // 2
            bullet_y = self.y
            bullet = Bullet(bullet_x, bullet_y)
            self.bullets.append(bullet)
            self.last_shot_time = current_time

    def update(self, dt):
        if self.moving_left:
            self.move_left(dt)
        elif self.moving_right:
            self.move_right(dt)

        for bullet in self.bullets:
            bullet.update(dt)
            if bullet.is_off_screen() or bullet.to_remove:
                self.bullets.remove(bullet)

        self.bullets = [bullet for bullet in self.bullets if not bullet.is_off_screen()]

        if self.hit_tint_timer > 0:
            self.hit_tint_timer -= 1


    def move_left(self, dt):
        self.x = max(0, self.x - self.speed * dt)

    def move_right(self, dt):
        self.x = min(settings.SCREEN_WIDTH - self.width, self.x + self.speed * dt)

    def draw(self):
        # Apply tint if hit_tint_timer is active
        if self.hit_tint_timer > 0:
            tinted_image = self.image.copy()
            tinted_image.fill(self.hit_tint_color, special_flags=pygame.BLEND_RGB_MULT)
            self.screen.blit(tinted_image, (self.x, self.y))
        else:
            self.screen.blit(self.image, (self.x, self.y))
        # Drawing bullets...
        for bullet in self.bullets:
            bullet.draw(self.screen)

    def collides_with(self, shape):
        return self.y < shape.y + shape.size and shape.x < self.x + self.width and shape.x + shape.size > self.x

    def on_collision(self, target):
        # Collision handling, including starting the hit tint timer
        if isinstance(target, NPC):
            self.take_damage(20)
            self.hit_tint_timer = self.hit_tint_duration  # Start hit tint

    def on_miss(self):
        # Method implementation remains the same...
        self.take_damage(10)
        self.hit_tint_timer = self.hit_tint_duration  # Start hit tint on miss as well


    def take_damage(self, amount):
        # Damage taking logic...
        self.health -= amount
        # Start the hit tint timer whenever damage is taken
        self.hit_tint_timer = self.hit_tint_duration

    def is_alive(self):
        return self.health > 0

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/shared/game_settings.py:
# Screen dimensions
SCREEN_WIDTH = 450
SCREEN_HEIGHT = int(SCREEN_WIDTH * 16 / 9)

# Grid parameters
GRID_COLUMNS = 6
GRID_ROWS = 9
COLUMN_WIDTH = SCREEN_WIDTH / GRID_COLUMNS

# Colors
BLACK = (40, 30, 30)
WHITE = (225, 225, 225)
YELLOW = (255, 255, 0)
TURQUOISE = (164, 124, 248)
LIGHT_GREY = (150, 140, 140)
GREY = (90, 80, 80)
DARK_GREY = (50, 50, 50)
RED = (255, 0, 0)

# Player properties
PLAYER_WIDTH = 100
PLAYER_HEIGHT = 90
PLAYER_SPEED = 185

# Grid visibility
SHOW_GRID = False

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/shared/game_object.py:
# game_object.py
import uuid
from shared import game_settings as settings

class GameObject:
    def __init__(self, x, y, size, speed, name=None):
        self.x = x
        self.y = y
        self.size = size
        self.speed = speed
        self.to_remove = False
        self.name = name or self.generate_name()

    def generate_name(self):
        return f"{self.__class__.__name__.lower()}_{uuid.uuid4().hex[:6]}"

    def update(self, dt):
        self.move(dt)

    def move(self, dt):
        pass

    def draw(self, screen):
        pass

    def is_off_screen(self):
        return self.y < 0 or self.y > settings.SCREEN_HEIGHT

    def remove(self):
        self.to_remove = True

    def collides_with(self, other):
        return (
            self.x < other.x + other.size and
            self.x + self.size > other.x and
            self.y < other.y + other.size and
            self.y + self.size > other.y
        )

/Users/avio./dev/sb-ai-vision-demo/pygame-demos/shared/bullet.py:
# bullet.py
import pygame
from shared.game_object import GameObject

class Bullet(GameObject):
    def __init__(self, x, y):
        super().__init__(x, y, 4, 160)
        self.color = (225, 225, 225)  # White

    def move(self, dt):
        self.y -= self.speed * dt

    def draw(self, screen):
        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.size)

